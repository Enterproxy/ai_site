"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/explore/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askChat: () => (/* binding */ askChat),\n/* harmony export */   deleteDocument: () => (/* binding */ deleteDocument),\n/* harmony export */   fetchDocument: () => (/* binding */ fetchDocument),\n/* harmony export */   fetchDocumentById: () => (/* binding */ fetchDocumentById),\n/* harmony export */   fetchDocuments: () => (/* binding */ fetchDocuments),\n/* harmony export */   saveEditedDocument: () => (/* binding */ saveEditedDocument),\n/* harmony export */   sendChatMessage: () => (/* binding */ sendChatMessage),\n/* harmony export */   updateDocument: () => (/* binding */ updateDocument),\n/* harmony export */   uploadDocument: () => (/* binding */ uploadDocument)\n/* harmony export */ });\n/* harmony import */ var _premade_db_baseDocuments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../premade_db/baseDocuments */ \"(app-pages-browser)/./premade_db/baseDocuments.ts\");\nconst LOCAL_STORAGE_KEY = 'uploadedDocs';\n\nfunction loadUploadedDocs() {\n    if (false) {}\n    try {\n        const json = localStorage.getItem(LOCAL_STORAGE_KEY);\n        return json ? JSON.parse(json) : [];\n    } catch (e) {\n        console.error('loadUploadedDocs error', e);\n        return [];\n    }\n}\nfunction saveUploadedDocs(docs) {\n    if (false) {}\n    try {\n        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(docs));\n    } catch (e) {\n        console.error('saveUploadedDocs error', e);\n    }\n}\nasync function saveEditedDocument(id, data) {\n    const res = await fetch(\"/api/documents/\".concat(id), {\n        method: 'PUT',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(data)\n    });\n    if (!res.ok) {\n        console.error('❌ Błąd zapisu edytowanego dokumentu:', await res.text());\n        throw new Error('Nie udało się zapisać zmian');\n    }\n    return res.json();\n}\nasync function fetchDocuments(filters, query) {\n    const res = await fetch('/api/documents');\n    const text = await res.text();\n    if (!res.ok) {\n        let errMsg = text;\n        try {\n            const json = JSON.parse(text);\n            errMsg = json.error || JSON.stringify(json);\n        } catch (e) {}\n        console.error('Błąd pobierania dokumentów:', res.status, errMsg);\n        return _premade_db_baseDocuments__WEBPACK_IMPORTED_MODULE_0__.baseDocuments // fallback w przypadku błędu\n        ;\n    }\n    let all = [];\n    try {\n        all = JSON.parse(text);\n    } catch (e) {\n        console.error('Błąd parsowania JSON:', e);\n        return _premade_db_baseDocuments__WEBPACK_IMPORTED_MODULE_0__.baseDocuments;\n    }\n    if (all.length === 0) {\n        return _premade_db_baseDocuments__WEBPACK_IMPORTED_MODULE_0__.baseDocuments;\n    }\n    // filtrowanie\n    return all.filter((doc)=>{\n        var _doc_author, _doc_language;\n        const matchesQuery = !query || doc.title.toLowerCase().includes(query.toLowerCase());\n        const matchesAuthor = !(filters === null || filters === void 0 ? void 0 : filters.author) || ((_doc_author = doc.author) === null || _doc_author === void 0 ? void 0 : _doc_author.toLowerCase().includes(filters.author.toLowerCase()));\n        const matchesLanguage = !(filters === null || filters === void 0 ? void 0 : filters.language) || ((_doc_language = doc.language) === null || _doc_language === void 0 ? void 0 : _doc_language.toLowerCase().includes(filters.language.toLowerCase()));\n        const tagFilter = ((filters === null || filters === void 0 ? void 0 : filters.tags) || []).filter((t)=>t);\n        const matchesTags = tagFilter.length === 0 || tagFilter.every((t)=>{\n            var _doc_tags;\n            return (_doc_tags = doc.tags) === null || _doc_tags === void 0 ? void 0 : _doc_tags.includes(t);\n        });\n        const docDate = new Date(doc.date || '');\n        const matchesDateFrom = !(filters === null || filters === void 0 ? void 0 : filters.dateFrom) || docDate >= new Date(filters.dateFrom);\n        const matchesDateTo = !(filters === null || filters === void 0 ? void 0 : filters.dateTo) || docDate <= new Date(filters.dateTo);\n        return matchesQuery && matchesAuthor && matchesLanguage && matchesTags && matchesDateFrom && matchesDateTo;\n    });\n}\nasync function fetchDocument(id) {\n    const res = await fetch(\"/api/documents/\".concat(id));\n    if (res.ok) return res.json();\n    // fallback jeśli dokumentu nie ma w bazie\n    const fallbackDoc = _premade_db_baseDocuments__WEBPACK_IMPORTED_MODULE_0__.baseDocuments.find((doc)=>doc.id === id);\n    return fallbackDoc || null;\n}\nasync function askChat(prompt) {\n    const res = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            prompt\n        })\n    });\n    if (!res.ok) {\n        console.error('❌ Błąd czatu:', await res.text());\n        return 'Nie udało się uzyskać odpowiedzi.';\n    }\n    const json = await res.json();\n    return json.reply || 'Brak odpowiedzi.';\n}\nasync function sendChatMessage(messages) {\n    const res = await fetch('/api/chat', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            messages\n        })\n    });\n    if (!res.ok) {\n        console.error('❌ Błąd czatu:', await res.text());\n        return 'Nie udało się uzyskać odpowiedzi.';\n    }\n    const json = await res.json();\n    return json.reply || 'Brak odpowiedzi.';\n}\nasync function fetchDocumentById(id) {\n    const res = await fetch(\"/api/documents/\".concat(id));\n    if (!res.ok) return null;\n    return res.json();\n}\nasync function updateDocument(id, data) {\n    const docs = loadUploadedDocs();\n    const idx = docs.findIndex((d)=>d.id === id);\n    if (idx !== -1) {\n        docs[idx] = {\n            ...docs[idx],\n            ...data\n        };\n        saveUploadedDocs(docs);\n    }\n}\nasync function deleteDocument(id) {\n    const res = await fetch(\"/api/documents/\".concat(id), {\n        method: 'DELETE'\n    });\n    if (!res.ok) {\n        const txt = await res.text().catch(()=>res.statusText);\n        console.error('❌ deleteDocument error:', res.status, txt);\n        throw new Error('Usuwanie dokumentu nie powiodło się');\n    }\n}\nasync function uploadDocument(file, metadata) {\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('title', metadata.title || file.name);\n    formData.append('author', metadata.author || '');\n    formData.append('date', metadata.date || new Date().toISOString());\n    formData.append('language', metadata.language || '');\n    formData.append('tags', JSON.stringify(metadata.tags || []));\n    formData.append('keywords', JSON.stringify(metadata.keywords || []));\n    formData.append('content', metadata.content || '');\n    if (metadata.thumbnail) {\n        formData.append('thumbnail', metadata.thumbnail);\n    }\n    const res = await fetch('/api/documents', {\n        method: 'POST',\n        body: formData\n    });\n    const text = await res.text();\n    console.log('uploadDocument status', res.status, 'body', text);\n    if (!res.ok) throw new Error(text || res.statusText);\n    return JSON.parse(text);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TU4sSUFBSXFELFVBQVU7SUFDakQsT0FBT2pFLEtBQUtDLEtBQUssQ0FBQ2lCO0FBQ3BCIiwic291cmNlcyI6WyJEOlxcUHJvamVrdHlcXFpfQ2hhdEdQVFxcaWJ3X2Zyb250ZW5kXFxsaWJcXGFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMT0NBTF9TVE9SQUdFX0tFWSA9ICd1cGxvYWRlZERvY3MnXHJcblxyXG5pbXBvcnQgeyBiYXNlRG9jdW1lbnRzIH0gZnJvbSAnLi4vcHJlbWFkZV9kYi9iYXNlRG9jdW1lbnRzJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudCB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHRpdGxlOiBzdHJpbmdcclxuICBhdXRob3I/OiBzdHJpbmdcclxuICBkYXRlPzogc3RyaW5nXHJcbiAgbGFuZ3VhZ2U/OiBzdHJpbmdcclxuICB0YWdzPzogc3RyaW5nW11cclxuICBrZXl3b3Jkcz86IHN0cmluZ1tdXHJcbiAgY29udGVudD86IHN0cmluZ1xyXG4gIGZpbGVVcmw/OiBzdHJpbmdcclxuICB0aHVtYm5haWxVcmw/OiBzdHJpbmdcclxufVxyXG5cclxuZnVuY3Rpb24gbG9hZFVwbG9hZGVkRG9jcygpOiBEb2N1bWVudFtdIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBbXVxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBqc29uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfU1RPUkFHRV9LRVkpXHJcbiAgICByZXR1cm4ganNvbiA/IEpTT04ucGFyc2UoanNvbikgOiBbXVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ2xvYWRVcGxvYWRlZERvY3MgZXJyb3InLCBlKVxyXG4gICAgcmV0dXJuIFtdXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzYXZlVXBsb2FkZWREb2NzKGRvY3M6IERvY3VtZW50W10pIHtcclxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxyXG4gIHRyeSB7XHJcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShMT0NBTF9TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoZG9jcykpXHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcignc2F2ZVVwbG9hZGVkRG9jcyBlcnJvcicsIGUpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZUVkaXRlZERvY3VtZW50KGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RG9jdW1lbnQ+KTogUHJvbWlzZTxEb2N1bWVudD4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RvY3VtZW50cy8ke2lkfWAsIHtcclxuICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gIH0pXHJcblxyXG4gIGlmICghcmVzLm9rKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIHphcGlzdSBlZHl0b3dhbmVnbyBkb2t1bWVudHU6JywgYXdhaXQgcmVzLnRleHQoKSlcclxuICAgIHRocm93IG5ldyBFcnJvcignTmllIHVkYcWCbyBzacSZIHphcGlzYcSHIHptaWFuJylcclxuICB9XHJcblxyXG4gIHJldHVybiByZXMuanNvbigpXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERvY3VtZW50cyhmaWx0ZXJzPzogYW55LCBxdWVyeT86IHN0cmluZyk6IFByb21pc2U8RG9jdW1lbnRbXT4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2RvY3VtZW50cycpXHJcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KClcclxuXHJcbiAgaWYgKCFyZXMub2spIHtcclxuICAgIGxldCBlcnJNc2cgPSB0ZXh0XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZSh0ZXh0KVxyXG4gICAgICBlcnJNc2cgPSBqc29uLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGpzb24pXHJcbiAgICB9IGNhdGNoIHt9XHJcbiAgICBjb25zb2xlLmVycm9yKCdCxYLEhWQgcG9iaWVyYW5pYSBkb2t1bWVudMOzdzonLCByZXMuc3RhdHVzLCBlcnJNc2cpXHJcbiAgICByZXR1cm4gYmFzZURvY3VtZW50cyAvLyBmYWxsYmFjayB3IHByenlwYWRrdSBixYLEmWR1XHJcbiAgfVxyXG5cclxuICBsZXQgYWxsOiBEb2N1bWVudFtdID0gW11cclxuICB0cnkge1xyXG4gICAgYWxsID0gSlNPTi5wYXJzZSh0ZXh0KVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0LFgsSFZCBwYXJzb3dhbmlhIEpTT046JywgZSlcclxuICAgIHJldHVybiBiYXNlRG9jdW1lbnRzXHJcbiAgfVxyXG5cclxuICBpZiAoYWxsLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGJhc2VEb2N1bWVudHNcclxuICB9XHJcblxyXG4gIC8vIGZpbHRyb3dhbmllXHJcbiAgcmV0dXJuIGFsbC5maWx0ZXIoKGRvYykgPT4ge1xyXG4gICAgY29uc3QgbWF0Y2hlc1F1ZXJ5ID1cclxuICAgICAgIXF1ZXJ5IHx8IGRvYy50aXRsZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpXHJcblxyXG4gICAgY29uc3QgbWF0Y2hlc0F1dGhvciA9XHJcbiAgICAgICFmaWx0ZXJzPy5hdXRob3IgfHxcclxuICAgICAgZG9jLmF1dGhvcj8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJzLmF1dGhvci50b0xvd2VyQ2FzZSgpKVxyXG5cclxuICAgIGNvbnN0IG1hdGNoZXNMYW5ndWFnZSA9XHJcbiAgICAgICFmaWx0ZXJzPy5sYW5ndWFnZSB8fFxyXG4gICAgICBkb2MubGFuZ3VhZ2U/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVycy5sYW5ndWFnZS50b0xvd2VyQ2FzZSgpKVxyXG5cclxuICAgIGNvbnN0IHRhZ0ZpbHRlciA9IChmaWx0ZXJzPy50YWdzIHx8IFtdKS5maWx0ZXIoKHQ6IHN0cmluZykgPT4gdClcclxuICAgIGNvbnN0IG1hdGNoZXNUYWdzID1cclxuICAgICAgdGFnRmlsdGVyLmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICB0YWdGaWx0ZXIuZXZlcnkoKHQ6IHN0cmluZykgPT4gZG9jLnRhZ3M/LmluY2x1ZGVzKHQpKVxyXG5cclxuICAgIGNvbnN0IGRvY0RhdGUgPSBuZXcgRGF0ZShkb2MuZGF0ZSB8fCAnJylcclxuICAgIGNvbnN0IG1hdGNoZXNEYXRlRnJvbSA9XHJcbiAgICAgICFmaWx0ZXJzPy5kYXRlRnJvbSB8fCBkb2NEYXRlID49IG5ldyBEYXRlKGZpbHRlcnMuZGF0ZUZyb20pXHJcbiAgICBjb25zdCBtYXRjaGVzRGF0ZVRvID1cclxuICAgICAgIWZpbHRlcnM/LmRhdGVUbyB8fCBkb2NEYXRlIDw9IG5ldyBEYXRlKGZpbHRlcnMuZGF0ZVRvKVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIG1hdGNoZXNRdWVyeSAmJlxyXG4gICAgICBtYXRjaGVzQXV0aG9yICYmXHJcbiAgICAgIG1hdGNoZXNMYW5ndWFnZSAmJlxyXG4gICAgICBtYXRjaGVzVGFncyAmJlxyXG4gICAgICBtYXRjaGVzRGF0ZUZyb20gJiZcclxuICAgICAgbWF0Y2hlc0RhdGVUb1xyXG4gICAgKVxyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERvY3VtZW50KGlkOiBzdHJpbmcpOiBQcm9taXNlPERvY3VtZW50IHwgbnVsbD4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RvY3VtZW50cy8ke2lkfWApXHJcbiAgaWYgKHJlcy5vaykgcmV0dXJuIHJlcy5qc29uKClcclxuXHJcbiAgLy8gZmFsbGJhY2sgamXFm2xpIGRva3VtZW50dSBuaWUgbWEgdyBiYXppZVxyXG4gIGNvbnN0IGZhbGxiYWNrRG9jID0gYmFzZURvY3VtZW50cy5maW5kKGRvYyA9PiBkb2MuaWQgPT09IGlkKVxyXG4gIHJldHVybiBmYWxsYmFja0RvYyB8fCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc2tDaGF0KHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGF0Jywge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcHJvbXB0IH0pLFxyXG4gIH0pXHJcblxyXG4gIGlmICghcmVzLm9rKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCfinYwgQsWCxIVkIGN6YXR1OicsIGF3YWl0IHJlcy50ZXh0KCkpXHJcbiAgICByZXR1cm4gJ05pZSB1ZGHFgm8gc2nEmSB1enlza2HEhyBvZHBvd2llZHppLidcclxuICB9XHJcblxyXG4gIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpXHJcbiAgcmV0dXJuIGpzb24ucmVwbHkgfHwgJ0JyYWsgb2Rwb3dpZWR6aS4nXHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZW5kQ2hhdE1lc3NhZ2UobWVzc2FnZXM6IHsgcm9sZTogJ3VzZXInIHwgJ2Fzc2lzdGFudCc7IGNvbnRlbnQ6IHN0cmluZyB9W10pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKCcvYXBpL2NoYXQnLCB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBtZXNzYWdlcyB9KSxcclxuICB9KVxyXG5cclxuICBpZiAoIXJlcy5vaykge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIELFgsSFZCBjemF0dTonLCBhd2FpdCByZXMudGV4dCgpKVxyXG4gICAgcmV0dXJuICdOaWUgdWRhxYJvIHNpxJkgdXp5c2thxIcgb2Rwb3dpZWR6aS4nXHJcbiAgfVxyXG5cclxuICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKVxyXG4gIHJldHVybiBqc29uLnJlcGx5IHx8ICdCcmFrIG9kcG93aWVkemkuJ1xyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEb2N1bWVudEJ5SWQoaWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAvYXBpL2RvY3VtZW50cy8ke2lkfWApXHJcbiAgaWYgKCFyZXMub2spIHJldHVybiBudWxsXHJcbiAgcmV0dXJuIHJlcy5qc29uKClcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZURvY3VtZW50KGlkOiBzdHJpbmcsIGRhdGE6IFBhcnRpYWw8RG9jdW1lbnQ+KSB7XHJcbiAgY29uc3QgZG9jcyA9IGxvYWRVcGxvYWRlZERvY3MoKVxyXG4gIGNvbnN0IGlkeCA9IGRvY3MuZmluZEluZGV4KChkKSA9PiBkLmlkID09PSBpZClcclxuICBpZiAoaWR4ICE9PSAtMSkge1xyXG4gICAgZG9jc1tpZHhdID0geyAuLi5kb2NzW2lkeF0sIC4uLmRhdGEgfVxyXG4gICAgc2F2ZVVwbG9hZGVkRG9jcyhkb2NzKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZURvY3VtZW50KGlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgL2FwaS9kb2N1bWVudHMvJHtpZH1gLCB7IG1ldGhvZDogJ0RFTEVURScgfSlcclxuICBpZiAoIXJlcy5vaykge1xyXG4gICAgY29uc3QgdHh0ID0gYXdhaXQgcmVzLnRleHQoKS5jYXRjaCgoKSA9PiByZXMuc3RhdHVzVGV4dClcclxuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBkZWxldGVEb2N1bWVudCBlcnJvcjonLCByZXMuc3RhdHVzLCB0eHQpXHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzdXdhbmllIGRva3VtZW50dSBuaWUgcG93aW9kxYJvIHNpxJknKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZERvY3VtZW50KFxyXG4gIGZpbGU6IEZpbGUsXHJcbiAgbWV0YWRhdGE6IHsgdGl0bGU/OiBzdHJpbmc7IGF1dGhvcj86IHN0cmluZzsgZGF0ZT86IHN0cmluZzsgbGFuZ3VhZ2U/OiBzdHJpbmc7IHRhZ3M/OiBzdHJpbmdbXTsga2V5d29yZHM/OiBzdHJpbmdbXTsgY29udGVudD86IHN0cmluZyB9XHJcbik6IFByb21pc2U8RG9jdW1lbnQ+IHtcclxuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXHJcbiAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSlcclxuICBmb3JtRGF0YS5hcHBlbmQoJ3RpdGxlJywgbWV0YWRhdGEudGl0bGUgfHwgZmlsZS5uYW1lKVxyXG4gIGZvcm1EYXRhLmFwcGVuZCgnYXV0aG9yJywgbWV0YWRhdGEuYXV0aG9yfHwnJylcclxuICBmb3JtRGF0YS5hcHBlbmQoJ2RhdGUnLCBtZXRhZGF0YS5kYXRlfHxuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpXHJcbiAgZm9ybURhdGEuYXBwZW5kKCdsYW5ndWFnZScsIG1ldGFkYXRhLmxhbmd1YWdlfHwnJylcclxuICBmb3JtRGF0YS5hcHBlbmQoJ3RhZ3MnLCBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS50YWdzfHxbXSkpXHJcbiAgZm9ybURhdGEuYXBwZW5kKCdrZXl3b3JkcycsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLmtleXdvcmRzfHxbXSkpXHJcbiAgZm9ybURhdGEuYXBwZW5kKCdjb250ZW50JywgbWV0YWRhdGEuY29udGVudHx8JycpXHJcbiAgXHJcbiAgaWYgKG1ldGFkYXRhLnRodW1ibmFpbCkge1xyXG5cdGZvcm1EYXRhLmFwcGVuZCgndGh1bWJuYWlsJywgbWV0YWRhdGEudGh1bWJuYWlsKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goJy9hcGkvZG9jdW1lbnRzJywgeyBtZXRob2Q6ICdQT1NUJywgYm9keTogZm9ybURhdGEgfSlcclxuICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKVxyXG4gIGNvbnNvbGUubG9nKCd1cGxvYWREb2N1bWVudCBzdGF0dXMnLCByZXMuc3RhdHVzLCAnYm9keScsIHRleHQpXHJcbiAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcih0ZXh0fHxyZXMuc3RhdHVzVGV4dClcclxuICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KVxyXG59XHJcbiJdLCJuYW1lcyI6WyJMT0NBTF9TVE9SQUdFX0tFWSIsImJhc2VEb2N1bWVudHMiLCJsb2FkVXBsb2FkZWREb2NzIiwianNvbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwic2F2ZVVwbG9hZGVkRG9jcyIsImRvY3MiLCJzZXRJdGVtIiwic3RyaW5naWZ5Iiwic2F2ZUVkaXRlZERvY3VtZW50IiwiaWQiLCJkYXRhIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwidGV4dCIsIkVycm9yIiwiZmV0Y2hEb2N1bWVudHMiLCJmaWx0ZXJzIiwicXVlcnkiLCJlcnJNc2ciLCJzdGF0dXMiLCJhbGwiLCJsZW5ndGgiLCJmaWx0ZXIiLCJkb2MiLCJtYXRjaGVzUXVlcnkiLCJ0aXRsZSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJtYXRjaGVzQXV0aG9yIiwiYXV0aG9yIiwibWF0Y2hlc0xhbmd1YWdlIiwibGFuZ3VhZ2UiLCJ0YWdGaWx0ZXIiLCJ0YWdzIiwidCIsIm1hdGNoZXNUYWdzIiwiZXZlcnkiLCJkb2NEYXRlIiwiRGF0ZSIsImRhdGUiLCJtYXRjaGVzRGF0ZUZyb20iLCJkYXRlRnJvbSIsIm1hdGNoZXNEYXRlVG8iLCJkYXRlVG8iLCJmZXRjaERvY3VtZW50IiwiZmFsbGJhY2tEb2MiLCJmaW5kIiwiYXNrQ2hhdCIsInByb21wdCIsInJlcGx5Iiwic2VuZENoYXRNZXNzYWdlIiwibWVzc2FnZXMiLCJmZXRjaERvY3VtZW50QnlJZCIsInVwZGF0ZURvY3VtZW50IiwiaWR4IiwiZmluZEluZGV4IiwiZCIsImRlbGV0ZURvY3VtZW50IiwidHh0IiwiY2F0Y2giLCJzdGF0dXNUZXh0IiwidXBsb2FkRG9jdW1lbnQiLCJmaWxlIiwibWV0YWRhdGEiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwibmFtZSIsInRvSVNPU3RyaW5nIiwia2V5d29yZHMiLCJjb250ZW50IiwidGh1bWJuYWlsIiwibG9nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});